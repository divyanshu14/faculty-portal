/*-------------------------------------------------------------------------------------------------------------*/

/* changing fac_email or fac_emp_id is not allowed */
/* even department change means deleting faculty from department and then adding new in the other department, so logically this operation is illogical */
CREATE TABLE faculty(
	fac_email VARCHAR (255) NOT NULL PRIMARY KEY,
	password TEXT NOT NULL,
	fac_emp_id INTEGER REFERENCES employee(emp_id) ON DELETE CASCADE NOT NULL,
	fac_dep_name VARCHAR (255) REFERENCES department(dep_name) ON DELETE CASCADE ON UPDATE CASCADE NOT NULL,
	fac_doj_of_dept DATE NOT NULL DEFAULT CURRENT_DATE
);

/* read only */
CREATE TABLE deleted_faculty(
	fac_email VARCHAR (255) NOT NULL PRIMARY KEY,
	password TEXT NOT NULL,
	/* employee may or may not be deleted */
	/* no need of on delete cascade because is_employee_deleted table is read only */
	fac_emp_id INTEGER REFERENCES is_employee_deleted(emp_id) NOT NULL,
	/* department name may or may not be deleted, but update the name here whenever it's updated */
	/* no need of on delete cascade because is_department_deleted table is read only */
	fac_dep_name VARCHAR (255) REFERENCES is_department_deleted(dep_name) ON UPDATE CASCADE NOT NULL,
	fac_doj_of_dept DATE NOT NULL,
	fac_dol_of_dept DATE NOT NULL DEFAULT CURRENT_DATE
);

/* read only */
CREATE TABLE is_faculty_deleted(
	fac_email VARCHAR (255) NOT NULL PRIMARY KEY,
	is_deleted BOOLEAN NOT NULL
);


/*-------------------------------------------------------------------------------------------------------------*/

CREATE OR REPLACE FUNCTION check_fac_email_fac_emp_id_fac_dep_name_change() RETURNS TRIGGER AS
$$
BEGIN
	IF OLD.fac_email <> NEW.fac_email OR OLD.fac_emp_id <> NEW.fac_emp_id OR OLD.fac_dep_name <> NEW.fac_dep_name THEN
		RAISE EXCEPTION 'Must not change email or employee id or faculty department';
	END IF;
	RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER check_fac_email_fac_emp_id_fac_dep_name_change_trigger
BEFORE UPDATE
ON faculty
FOR EACH ROW
EXECUTE PROCEDURE check_fac_email_fac_emp_id_fac_dep_name_change();


/*-------------------------------------------------------------------------------------------------------------*/

CREATE OR REPLACE FUNCTION populate_is_faculty_deleted() RETURNS TRIGGER AS
$$
BEGIN
	INSERT INTO is_faculty_deleted (fac_email, is_deleted) VALUES (NEW.fac_email, FALSE);
	RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER populate_is_faculty_deleted_trigger
BEFORE INSERT
ON faculty
FOR EACH ROW
EXECUTE PROCEDURE populate_is_faculty_deleted();


/*-------------------------------------------------------------------------------------------------------------*/

CREATE OR REPLACE FUNCTION log_deleted_faculty() RETURNS TRIGGER AS
$$
BEGIN
	INSERT INTO deleted_faculty (fac_email, password, fac_emp_id, fac_dep_name, fac_doj_of_dept) VALUES (OLD.fac_email, OLD.password, OLD.fac_emp_id, OLD.fac_dep_name, OLD.fac_doj_of_dept);
	UPDATE is_faculty_deleted SET is_deleted = TRUE WHERE fac_email = OLD.fac_email;
	RETURN OLD;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER log_deleted_faculty_trigger
AFTER DELETE
ON faculty
FOR EACH ROW
EXECUTE PROCEDURE log_deleted_faculty();


/*-------------------------------------------------------------------------------------------------------------*/
